Rust Notes 

Uses 4 spaces instead of tab

!-symbolises macros- they are like functions#compile and runtwo steps compile - rustc main.rs
Run - ./mainCargo
cargo new hello_rust
 Compile- cargo build
 Run - ./target/debug/hello_cargo
 Compile and run - cargo run check if it compiles - cargo check
Cargo build —release Programming a guess Game
Prelude-a list of things rust imports in every rust program
By default variables are Immutable meaning they can’t change, TO MAKE THEM MUTBLE WE pass mut keyword

 let mut guess = String::new();
    // mutable  variable guess binded to a new empty instance of a string


 Generating secret Number
Rust does not have random number generation functionality in its standard library but there is a rand crate  with said functionality	crate is a collection of  rust source code
Rand crate - is a library- code intended to be used by other programs not executed on its own.
Cargo doc —open documentation  locally available to developers Match- an expression made up of arms, the arms consist of a pattern to match against, and the value to be run if the value given to the match fits the the arms patternshadowing allows us to reuse a variable- esp when converting it from one type to another

parse method on strings convert strings to another type, however we must type the variable accordinglyi.e
let string=“9”let number:i32=string.parse().expect(“failed”);

Variables
In rust “” (double quotes-string) while ‘’ (single quotes -character)constants are immutable in nature, usually in uppercase  and must have type declarecred, 
Mutability - ability of a variable to be reassigned another valueDataType
Every rust value has a type to tell what kind of data is being specified so as to know how to work with that data
1.scaler-datatypes that represent single value I.e integer, floating-point, numbers, boolean, characters
Default integer type is i32.
-Integer overflow wrapping - The values greater than the minimum value a type can hold, wrap around to the minimum of the values the type can hold
2.compound- datatypes that group multiple values into one1.turple a group of a number of different elements of different type. cannot grow or shrink-immutablelet tup:(i32, f64, u8)=(500,6.4,1)
Access individual values via:  1. destructuring the turple
2. Dot index of item let tano=tup.0

Unit- turple without any value
Let tup:()=()

2.Array
Collection of multiple values with same typeshave fixed length - don’t grow or shrink
Type it by setting the datatype of the numbers followed by the number of elements
Let array:[I32,5]=[12,12,12,33,3]

Initialise array to contain same values
As let array a= [3;10]will contain 10 elements defaulting to number 3accessing the array-a[3]Polymorphism- oop concept to access objects of different types through same interfaceI.e java in different functions can have same name but the correct will run depending on the parameters past

FUNCTIONS-uses snake case for functions and variables 
Parameters- are placeholders for arguments
Arguments- real values passed to the function
Passing the type of a parameter, ensures you don’t need to define the type ever again in the scope, also provide more error messages

Statements are instructions that perform some action but don’t return a value I.e let y=6; assignment is a statement 
Expressions evaluate to resultant value I.e calling a function, macro, a new curly brackets is a expression I.elet y={
    let x=3;
        x+1
}
If you add a semicolon  at the end of the last line the curly brackets changes to a statement and hence the code doesn’t compile


A function can return a value but the type must be defined after the arrow 

Control Flowif condition
loops-loop{}
Loops are infinite, 
Stops code execution using break;you can also return a value from a loop by adding the value you want returned after the break then assign the loop to a variable I.e refer to loops code in rusty
-while loop- eliminates combination of loop and if else
-if else
-for loop - much better suited for loop with collections I.e arrays OWNERSHIP
Set of rules that govern how rust program manages memory.
Gives rust memory safe superpowers.
HEAP AND STACK
Both the stack and the heap are parts of memory available to your code to use at runtime
STACK
Uses last in, first out approach Adding data to stack is pushing, pop is the oppositeAll data stored on the stack must have a known, fixed size. 
Data with an unknown size at compile time or a size that might change must be stored on the heap

HEAP
Less organised,to put data on the heap, you must request for a certain amount of space, memory allocator will then look for space that is big enough and mark it as in use, and returns a pointer which is the address of that location - Allocating the heap or just allocatingAdding data to stack is not allocatingBecause the pointer is a known, fixed size, you can store the pointer in a stack, but when you want the actual data you must follow the pointerPushing to stack is much more faster and efficient since the allocator does not need to look for memory in the first place.Accessing data in heap is much more slower than stack because you don’t have to follow a pointer, data is scatteredProcessor are faster if they jump less in memory, and access data in a more organised manner.
When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.Ownership rules~Each value in rust has an owner.
~Each value can only have one owner at a time 
~when the owner goes out of scope the value is dropped
The String Type:a value of type string is most likely stored on the heap as it contains data that is of an unknown size at runtime (mutable) as compared to other data types discussed above.
A value of type String is mutable while a  string literal ie. let =“hey” is immutable
Use push_str to mutate and append strings - // push_str() expects type &str


In rust memory is automatically returned once the variable goes out of scope. Rust calls drop method(which will return the memory ) at the closing of curly brackets
I.e in for type string the stack will store length, capacity and pointer. The pointer will in turn point to the memory location used on the heap
Length- memory in bytes that the contents of type String are usingCapacity - memory in bytes that the  type String has received from allocator
Note :
Since we store data from type string in heap and the pointer etc on stack, copying a variable of string type to another only copies the 3 pieces of data stored on the stack, the actual data held by the variable is not copied, if mishandled this might lead to compilation errorsI.e s1=s2If rust somehow would be able to copy both the data  on the heap and stack this would be a very expensive calculation.One of rust design choice is to never create deep copies of your data(only copy data on stack memory), therefore any automatic coping is assumed to be inexpensive(shallow copy) in terms of runtime performance.
Since rust cleans up and drops memory when a variable goes out of scope, when binding one string to another they both point to the same memory and hence they can drop the same memory(double freeze error), however after the line s1=s2 rust no longer considers s1 valid and doesn’t free anythingsince we are only copying the 3 pieces of data it is refereed to as shallow copy but in rust, since we take the step further and invalidate the memory we call it a moveto copy data without invalidating we can use .clone() method- this may be expensive Integers however are of a known size at compile time so they are stored on the stack and making copies is not that expensive hence we can use : let y=5; let x=y;   without clone methodwe have access to  a special annotation called the copy trait that we can place on data stored on stack, if the type is implemented the variable can be copied without invalidation.however the type must not have implemented  the Drop trait priorAny group of simple scalar value can implement the copy trait.Ownership and Functions
Passing a variable to a function will copy or move the variable just like assignment,in order to retain the ownership we can return the passed parameter back to return ownership
  Or use references as explained below
Return Values 
Return values from functions also return ownershipReferences and Borrowing
-refer some value without ownership
Opposite is dereferencing which uses *
Reference- is like a pointer we can follow to access data stored on that address, usually data is owned by another variableguaranteed to point to existing and valid data unlike an actual pointer.		The concept of losing ownership each time you pass a variable to a function is a bit too much, hence we introduce references.Borrowing
The Process of creating references
Immutable by default- cannot be changed
You cannot borrow more than one value at a time 
This prevents data races: they can occur in either of the following reasons:
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There’s no mechanism being used to synchronize access to the data.
Not possible:
    let r1 = &s; // no problem
    let r2 = &s; // no problem
    let r3 = &mut s; // BIG PROBLEM

We can use curly brackets to our advantage though, to set up scopes and hence use multiple refences.	Note a reference’s scope starts from where it is introduced and continues through the last time that reference is used.
Possible:     {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;you can have multiple immutable references assignment as immutable reference only read and don’t change the data of the variable

Dangling references.
Sometime we can have a pointer pointing to some non existent location in memory or to a location that might have been given to some other owner.
Rust prevents this by a compile time error

Reference rules1 A reference must be valid at all times.
2 You can only have one mutable reference or a number of immutable references at a time
- Having a single mutable reference ensures we prevent data races,The Slice Type
A kind of reference.
Enables you to reference a consecutive subset of elements within a collection rather than the entire collection.(potion of a string)
Does not have ownership.
We create references by using a range within brackets by specifying the starting index and  end index which is not included	
Length of slice = ending index - starting index
I.e [0..10] -from 0 -10 , 10 not included
I.e [..] - whole string
i.e [..6] - starting from zero, 6 not included
Type that signifies string type is &str -note difference with &String
as_bytes()=convert strings in to an array of bytes
iter()=is a method that returns each element in a collectionString literals as Slices.
Both use the &str type 
Meaning they are both immutable references.
String literals are stored inside the binary, this means they are part of something
This means that string literals are slices already by default;
&String-mutable
&str-immutable
When passing parameters to function a more experienced rustacean would use the &str type instead of the &String type as it allows for much more functionality
 Check GitHub for more	 
String slices are generally used as part of a string but there are other types of slices too I.e array slices.

Array slice i.e 
Let array=[1,2,3,4,5,6,7,8,9];
Refer to GitHub


Defining and instantiating Structs
Structs are like tuples in that they hold multiple related values of different typessimilarity: can hold data of different types
diff: in structs, you’ll name each piece of data so its clear what the values means, in tuples you have to use the index to access the particular value of data.
Adding name means structs are more flexible in that you don’t have to rely on the order of data to specify or access the values of an instance.
Basically the structure of structs is similar to an object interface in js
To use a struct we define an instance of the struct and add curly brackets with key and pair -just like in js
user{age:i32,
Name:String,
}

Let user= user{age:String::from(23),
Name:string::from(“luiio”),
}

We can create instances from other instances using the struct update syntax (..) two dots , which looks like speed operator in js (…) three dots
Let user1=user{
Name:string::from(“luv”),
..user
}
we use assignment  operator = unlike colon in js where we use colon as such:we use the assignment operator to show that that data is being moved,(however note that those datatypes that implement the copy trait are usualy not moved but rather copied)
however the struct will become invalid if we spread data on it stored on the heap i.e (Strings,Compound types) to another struct
however if we spread only scalar datatype, struct is still valid,

Turple structs
They have the added meaning of a struct but don’t have name fields rather only a name and the types of the field
Example of a tuple:
Let tuple:(i32,i32,f64)=(0,0,0.90);
Example of a tuple struct:
struct Point(i32, i32, i32);

Useful for when you want give the whole tuple a name and make the tuple of different type from the rest.useful when writing the name for each field would be verbose.

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}

Unit-Like Structs Without Any Fields
You can also define unit like structs, this are structs that don’t have any fields, behave similarly to ()useful when you want to implement a trait on some type but don’t have any data that you want to store in the type itself
struct AlwaysEqual;
let main=AlwaysEqual;Ownership of Struct Data
In structs in order for the struct data to be valid, we use String type rather than string refernces, this way we ensure our data is valid, however we could use string references as well, but include lifetimes in themlifetimes ensure data referenced by the structure is valid as long as the structure is valid.

An Example Program Using Structs
Refer to GitHub
 
Structs  in general will group related data that work together
By default we can’t use the println macro to display complex data like structs, this is because structs don’t implement the ‘Display’ trait.Instead we can {:?} use instead of {}  just to inform the compiler we want to use an output format called debug we must also explicitly	opt in to debugging information by adding #[derive(Debug)] before structs definition

Instead of println!() we can use dbg!()however it takes ownership of a expression, prints file and line number and the value and returns the ownership
-we can pass a reference instead to counter this ;)

Defining methods in structs:
Methods are defined within the context of a struct (or enumeration or trait object)
Methods are like functions but their first parameter is always self, which rep the instance of the struct the method is being called on.
I.e  struct_instance.method()
Check github

Methods also take ownership,borrow mutably or immutably and return ownership as wellAssociated functions
All functions defined within an impl block are called associated functions because they’re associated with the type named after the implAssociated function are  be  defined without passing self as first parameter and hence they are not considered to be methods I.e String::from(“text”) - from is an associated function hereAssociated function are not methods,
They are used in making constructors that return a new instance of the struct often called new, new is not a keyword in rust though
Impl Rectangle{
fn square(size:u32)-> Self{
Self{
Width:size,
Height:size,
}
}
}check GitHub


Enums and pattern matching
Enums allow you to define a type by enumerating its possible values.
You can also use enums to store related data.
As well as store data in. More concise manner.
Values inside an enum should begin with capital letters

enum IpAddrKind{V4,
V6(String)
}

IpAddrKind - becomes a custom datatype that we can use
We can create instances as follows:
Let four=IpAddrKind::V4
Enums can as well hold their data
Let six=IpAddrKind::V6(String::from(“luv”))

We can use enums as well to store data in a more concise manner
Enums allows us to store more complex data even than structs:
Enum ipAddr{
V4(u8,u8,u8,u8),
V6(String)
}

We can basically  hold any data with enums, including other enums,  structs etc
Just like in structs we can define methods on enums using the impl keyword The Option Enum and its adv over null values

enum Option<T>{None,
Some(T)
}The standard lib has a couple of predefined enums and option is one of them,- it is defined in the prelude, so there is no need to import it again
it basically encodes a scenario where a value could be something or nothing, preventing null values.
Rust does not have the null feature that many languages have, null means that there is no value.

In rust anywhere we see Option<T> we can assume that the value will at one point have a null value,
Likewise to use a value that might be null, we must explicitly use the Option<T> type.

This usually defined in the std lib 
it is so useful that it is included in the prelude, we can even use the values without the option:: prefix,,check code below

Let value=Some(5)
Value will be of type Option<i8> and not i8- note these are two different types and hence if you try to add them etc you might get a compiler error.
option enumeration has a large number of inbuilt methods.
Check GitHub

The match Control flow Construct
Allows you to compare values against series of patterns and execute code based on which pattern matches
Things you can do with match:1. Bind to values (help in extracting values from enumerated variants)	
2. Matching with option T to check whether the value is a None  value 

List match keyword followed by an expression , followed by  arms: have two parts (pattern and some code) i.e(coin::Penny) and the  => operator with separates the pattern , then followed by code -check GitHub
Diff with IF : with if the condition needs to evaluate to a boolean value, here it can be any type.

Extracting values from enum Variants
Match expressions  can help achieve this, check out GitHub

Match with option<T>
-say you want to check if value is available before you execute function, you can use match: check GitHub
Match keyword followed by an expression.more like how an if statement is but the difference is that the if must result to a boolean while match can result in any type

Change Option<T> to T in rust
We can use the match expression to do the conversion as below:  let optional_five = match five {
        None => 0,
        Some(five) => five,
    };
Notice at none I returned zero, this will depend on you and how you want to work with your data.
Matches are exhaustive:we must exhaust every last possibility in order for the code to be valid. 
- they won’t compile if you have not covered all possible values, I.e won’t compile if you check for some(I) only when the type is of Option<T> (you have left out None and the compiler knows that)this addresses the billion dollar mistake of having null values in our code.catch all patternusing the match expression on enums we can perform special functions on some values and one for the rest (catch-all). check GitHubthis ensures that the match expression id exhaustive and handles and cases avoiding the billion-dollar mistake we are trying to evade in the first place.
For The catch all we can use the specific value passed to the function executing our match and these value will bind to the value of the specific enum variant should the pattern matchAlternatively we could use the inbuilt catch_all (_).
It will however not bind to the value of the resulting variant of the enum.
IF LET
Let’s you compare values  that match one pattern and ignore the rest in a less verbose manner as compared to match statement.we don’t have to include that _ => () bs as in match
However you loose exhaustive checking that match enforces.takes a pattern followed by an expression separated by equals sign
 Let a =some(2U8)
If let Some(x)= a{
Print!({max})
}
If let can also have an else statement. The else block will run code that would be equivalent to _ => () above.for example we can include code to incrementally count the number once a value doesn’t match a pattern GitHub


Managing Growing Projects with Packages, Crates, and Modules

As code grows we will need to separate and group related code
A package can contain multiple binary crates and optionally one library crate
As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. 
We’ll also discuss encapsulating implementation details, which lets you reuse code at a higher level: some parts of our code can be public while others are privateScope-  programmers and compilers need to know whether the name used in a particular block of code refers to a variable, function enum, struct.etc, for this we can define a scope were that part of the code can only have one name occurrence.
Rust has a number of features that allow you to manage your code’s organization, including which details are exposed, which details are private, and what names are in each scope in your programs. These features, sometimes collectively referred to as the module system, include:
* Packages: A Cargo feature that lets you build, test, and share crates
* Crates: A tree of modules that produces a library or executable
* Modules and use: Let you control the organization, scope, and privacy of paths
* Paths: A way of naming an item, such as a struct, function, or module

Packages and Crates
Crate- Is the smallest amount of code that the rust compiler considers at a time(collection of rust source code that compiles at the same time)-Binary crate
-Library crate

Binary crate- rust code that you can compile to an executable and run (smallest hello world code is a crate it self)
It contains a main fn that defines what’s happens when the executable runs
Library crates - don’t compile to an executable neither do they have a main fn but rather define functionality intended to be used by multiple	projects.

But in general crate means a library as used in other languagesPackage- is a bundle of one or more crates that provides a set of functionality
A package contains cargo.toml file that  describes how to build this crates
A package can contain more than one binary crate but at most one library crate and at least one crate	
If cargo finds a src/main.rs it knows this is a binary crate and if it finds a src/lib.rs it knows this is a library crate.
To have multiple binary crates place your files inside src/bin directory

Defining Modules to Control Scope and Privacy
1. Start from the crate root- compiler will check in the root of the crate for usually main.rs or lib.rs
2. Declaring modules-modules are declared in the crate root file. E.g mod Garden;
* The compiler will look for the module’s code in these places:
* Inline, within curly brackets that replace the semicolon following mod garden
* In the file src/garden.rs
* In the file src/garden/mod.rs
3.Declaring sub modules- can be declared in any other file apart from the root crate
* The compiler will look for the module’s code in these places:
* Inline, within curly brackets that replace the following mod garden
¸¸¸¸* In the file src/garden/vegetable/zzy
4. Path to code in modules-once a module is part of your crate, you can refer to any code in that crate as long as privacy rules still apply.eg to refer to type Asparagus we doit as  crate::garden::vegetable::Asparagus
5. Private vs Public-code within a module is private by default to make public we add the keyword pub before mode
6. Use keyword- Within a scope, it creates shortcuts to reduce repetition of the long paths.i.e in this path crate::garden::vegetables::Asparagus we can “use crate::garden::vegetables::Asparagus” and from then on we only need to write Asparagus to make use of that type in the scope

Grouping Related Code in Modules
Modules helps use increase readability, reusabilty and privacy of items-modules are private by default.
Create a lib with cargo cargo new restaurant —lib
Modules can hold defination of other items e.g structs,enums, constants, traits- hence you might find them gropued together and named why they are related.
Devs reading the code can navigate with modules instead of reading through all the definitions in order to find the relevant code they are looking for
src/main.rs and src/lib.rs are referred to as root crates because the contents of either of the two files form a module named crate at the root of the crates module structure (module tree)
Paths for Referring to an Item in the Module Tree

We use paths to find an item in a modules- just like any prog language
Absolute path - full path starting from a crate root,
For Code from an external crate, absolute path begins with the crates name and for code in our current crate the absolute path begins with the literal crate.Relative path - starts from the current module and self , super 	or any identifier in the current module
-both are followed by one or more identifier separated by doubles colonin rust all items( functions, enums, structs) are private to the parent module by default; hence incase you need to privatize something just put inside a module
Basically children can access parents but parents cannot access children by default unless we give them that option.making a module public does not make the items in the modules public, you will have to make them public as well- this includes structs, enums, etc.-Modules are containers

Starting Relative Paths with super
We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using super at the start of the path-  like using .. syntax
I.e 
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}

Making Structs and Enums Public
For structs 
We will use pub like before however, a struct can be public but its field not public, hence we must also specify which fields are going to be public or not
pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
enums
Pub keyword on the enum name alone will do the trick here

Bringing Paths into Scope with the use Keyword
Use reduces the code we need to write while referring to a path I.e check out code below
use crate::front_of_house::hosting;
    hosting::add_to_waitlist();

Declare use in the scope you’d want to use the imported modules, structs ,functions etc. - declaring use at the top level then trying to use it inside a module wont work since the scope is different.
Alternatively you can append ‘super::’ before your function, etc to make it accessible

Creating Idiomatic use Paths
Above you might wonder why we didn’t do this
use crate::front_of_house::hosting::add_to_waitlist();
add_to_waitlist();
It is ideally idiomatic/recommended to call a function with its parent, so that it’s clear where the function comes from. I.e
hosting::add_to_waitlist();
When calling other items, I.e structs, enums etc it is advisable to write the full path in the use statement I.e:
use std::collections::HashMap;
It’s the way people write rust code.

Providing New Names with the as Keyword
Sometime we may have to import two items with the same name within our crate, we can use the as keyword to differentiate between	 the two
use std::fmt::Result;
use std::io::Result as IoResult;Re-exporting Names with pub use
When we bring a name into scope it’s only available in the new scope which is private, to give the code that calls our code access to that name use can combine use and pub keywords
This technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope.
Check the book example

Using External Packages
 To use external package we must define	 the package name in our cargo.toml file and then use the use statement to import the package in our project. e.g  use rand::Rng;
Std library for example is an external crate to our package but it ships with rust so we don’t need to include it in the cargo.toml file, however to use it we must import it using the ‘use’ keyword.
 use the absolute path to bring in external crates

Using Nested Paths to Clean Up Large use Lists
Importing different items from the same modules tends to take a lot of vertical space, hence we can use nested paths to bring into scope the same items in one linewe specify the common module followed by two colons then a curly brackets with what we want to import
e.g use std::{cmp::Ordering, io};
If we have 
use std::io;
use std::io::Write;
And decide to use nested paths instead we will do it this wayuse std::io::{self,Write}

The Glob Operator - *
 If we want to bring all public items defined in a path we can use glob operator - *

Separating Modules into Different Files
While separating a module from the root file is good in reducing code complexity and readability , we need to understand how to import the module,
Check GitHub project - module
We first have to load the file using the mod declaration

8.
Common Collections
Collections in rust are data structures that store multiple values, unlike arrays or tuples, collections are stored on the heap.Arrays have a fixed known size hence they are stored on the stack
* A vector allows you to store a variable number of values next to each other in memory.  Vec<T>
* A string is a collection of characters	
* A hash map allows you to associate a value with a particular key.

Storing Lists of Values with Vectors
Allows us to store more than one value in a single data structure next to each other in memory
To create a vector we can  use the Vector::new() function or using the vec!
 let v: Vec<i32> = Vec::new(); //here you have to give the type
The Vec<T> can hold any typewhen we create a vector and pass a value to it , rust can infer the type from the value so we rarely have to type it.
However if you create an empty vector you must explicitly type it since rust can’t infer it.
Rust has a vec! Macro which will create a new vector that holds the value you give it.
let vec=vec![1,2,3]

Updating a Vector
We can use the push method to add items to our vector
Like any variable in order to change it we must add the mut keyword
Let vec=Vec::new(); // creates a new empty vector
vec.push(9);

Reading Elements of Vectors

They are two ways of referencing vectors , using indexing syntax or the get method
Let third:&I32=&vec[2]; //indexing
Let third:Option<&I32>=vec.get(2);

Using indexing and & will give us the reference of the index value of the vector
Using get method returns Option<T>  which we can use with match to get the Some<T> and None types
Some<T>-will give us the actual value,
None- to handle the case of null values
Hence here :
Let third:Option<&I32>=vec.get(2); 
we can’t use the &(reference) since get will return  Option<&i32> instead of &i32
Usage of these two depends on your application needs, eg if you access a non existent value with indexing the program will panic, but if you use get  you can handle null cases with None- eg if the index is a user input you can handle a case and ask them to reenter the number again.

As seen we have not listed vec3 are used it, this is because vectors store items next to each other on memory and adding a new element might cause new memory allocation of the vector, as such reference t the first element or any other, might be referencing a deallocated memory I.e:let mut v =vec![1,2,3,4,5];
Let first= &vec[0];  
V.push(6);
 println!("The first element is: {first}");

Pop-removes and returns the last element 

It is not allowed to mutate a vector that is stored on the heap and has been accessed immutably- this tells the compile we are going to perform a read only operation.vector store there value next to each other hence adding a value might lead to memory re-allocation and copying the values if the current doesn’t fit.Hence if we add a new value and try to access your vec we might be accessing a wrong memory hence rust won’t allow you to read the value after you have mutated- program will panic

So far we have used match structs, enums and vectors

Iterating over the Values in a Vector

To access each item inside the vector we can use for loop to iterate and access immutable values
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }
For mutable vectors we can modify them by the help of deference operator
To change the value that the mutable reference refers to, we have to use the * dereference operator to get to the value in i before we can use the += operator.  let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }

We normally pass reference to the vector in a for loop because :
1. The loop would assume ownership of the vector if we did not pass the reference instead- we wouldn’t be able to use the vector again
2. It prevents simultaneous modifications of the vector at the same time.- Ensure we have only one reference to a mutable data Structure
Using an Enum to Store Multiple Types
A vector can only store values of the same type, this is unconvincing because there are definitely uses cases where wed want to store values of different types in our vector, however the power of the enum can help us here:
So basically an enum can have multiple values of different types stored together under one type; that of the enum.
We can essentially  store the different types to the enum , create a vector and pass that enumerates to the vector.
enum SpreadSheet{
Int(i32),
Float(f64),
Text(String)
}

Let v =vec![SpreadSheet::Int(4),SpreadSheet::Float(4.87656789),SpreadSheet::Text(String::from(“Slash”)] ;

Dropping a Vector Drops Its Elements
Like any other struct, a vector is freed when it goes out of scope,so a vector is a struct?

STRINGSStoring UTF-8 Encoded Text with Strings:
Strings are implemented as a collection of bytes, and has some methods to provide functionality when those bytes are implemented as text.here we will discuss:1. operations on strings that every collection type has I.e creating , updating and reading
2. How strings are different from other collections, namely how indexing to a string is different namely in differences between how people and machines interpret it.
What Is a String?
Rust has only one string type in the core language which is the string slice seen as &strstring slices are usually references to UTF-8 encoded string data stored else where;
 string literals are stored in the programs binary and therefore are string slices
String type is provided by the standard library rather than being coded into the language , is a growable, mutable, owned UTF-8 encoded string type 
Both String type and &str are UTF-8 encoded

Creating a New String
Many of the operation available for String are available for vector;
String is implemented as a wrapper around a vector of bytes with some extra guarantee, restrictions and capabilities
Eg the new function. String::new() // Vec::new()this creates an empty String but often we wan to have some initial data, we can use this:1.to_string()- which is available to any type that implements  the display trait	
Let s=“initial text”.to_string();
2.String::from(“initial_tetx”);which one to choose is upto yourself, style and readability Strings are UTF-8 so they can store symbols,characters, emojis, text, etc.
Updating a String1. concatinate with Plus operator (+) - to avoid ownership lose add a reference to the concatenation values.
2. concatinate with format!()
3. Append a string with push_str()- does not take ownership
4. *Push - works like push_str but only for single characters 
Just like the vec<T> String can grow and change it contents if you push data into it.you can use the + or the format! to concatenate values

Appending to a String with push_str and push
You can use the push_str method to grow the string by appending a string slice
It does not take ownership of the StringSlice hence it can still be used 

Concatenation with the + Operator or the format! Macro

 let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
Si is no longer valid and the reason we used a reference to s2-&s2  has to to with the signature of the method called when the + operator is usedit looks like :
fn add(self, s: &str) -> String {}
We can only add &str to String and not String with Stringbut as seen we are trying to add &String to String even though the method signature says &str.this is because rust compiler can  coerce a String into a &str[..]also as add does not take ownership of s parameter we can still use s2.we can also see that add take ownership of self as it does not have a &meaning we  take ownership of s1, append a reference to s2 and return the result to s3; 
this statements looks like we are lots of copying but that is not the case, this is actually more efficient than copying your way into it.Remember above we said strings provide a little more capabilities but also restrictions.
Format MacroThis makes appending strings much more easier to read and write, especially when concatenating multiple stringsworks exactly like the println! But on this case we return the concatinated stringas seen variables are put in {} which is wrapped by double quote notation
format!(“{s1}-{s2}-{s3}”);

Indexing into Strings
If you try to index a string in rust as with other programming languages, you would get an error.
Rust does not support indexing in string, why not ? Let understand why
Some characters in string take more than one byte- usually a letter will take one byte.due to this if we try to access a string value with index, it may lead unto an unexpected behaviour thus rust won’t compile.

Bytes and Scalar Values and Grapheme Clusters! Oh My!
Another point about UTF8 is that there are three ways to looks at string from rust perspective
-bytes
-scalar values (chars)
-Grapheme clusters-closest thing we could call letters
As you can see rust stores string in different types so indexing would not be appropriate as there is no superior way to look at the strings
The final reason why indexing is not possible in rust string is because indexing is expected to take constant time (O(1)). But this isn’t possible to guarantee performance in rust as rust would have to walk through contents from the beginning to the index to determine how many valid charatcters there were.

Slicing Strings
 As we have seen indexing in rust might result to unexpected behaviour, and is difficult due to the three different type it can be stored as.however if you really need to index you can provide a range instead of an index with one number I.e
let hello = "Здравствуйте";
let s = &hello[0..4]; 4th item not included.
Instead of 
let hello = "Здравствуйте";
let s = &hello[4];

Since as discussed earlier this characters take 2 bytes instead of the	normal I byte hence you’d get s=Зд
If we were to to try and slice part of a character byte as in using the example abovelet s = &hello[0..1];we’d get a compile error
Be  careful on how you generate string slices from string to prevent program panicking

Methods for Iterating Over Strings:
The best way to operate on pieces of  strings is to be explicit on where you want chars or bytes.
For individual unicode scaler values use the chars method
Calling chars on  Зд returns the individual values of type char
For I in LOUis.chars(){
Println!(“{I}”);
}
Alternatively you can use the byte method which returns each raw byte,208,151,208,180
For I in LOUis.bytes(){
Println!(“{I}”);
}

Storing Keys with Associated Values in Hash Maps
This is the type HashMap<K, V>
Stores a mapping of  type K to values of type V using a hashing function.store their data on the heap
All keys must have same type as each other.
Object in JS
Stores a mapping of keys of type K to values of type V using a  a hashing function, which determines how it places this keys and values into memory
Hashmaps are useful when you wan to search for data, not by using index as with vectors but by using a key that can be of any type.
Hash maps are there least used among the rust collections hence they are not included in the prelude.
Creating a New Hash Map

Since they are not in the prelude, we need to use the use key word to bring them into scopeuse std::collections::HashMap;
We can create a new hash map by using the new keywordlet mut scores=HashMap::new() 
We can use insert to adding elements to the hashmap.
 scores.insert(String::from("Blue"), 10);

Jus like vectors, hashmaps are homogeneous, meaning there keys need to be of the same type and values as well, we can use enums to helps use here, incase we have items of different types we want to store in out hash map.
use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);


Accessing Values in a Hash Map

We can get a value out of a hashmap by using the get method.

Let Blue=“Blue”.to_string();
Let score =scores.get(&Blue).copied().unwrap_or(0);
The get method returns Option<&V>, if there is no value for that key the method returns  None.you could argue we could do a match here as well to handle the same value from get.
This program handles option by calling .copied() to get an Option<i32> type rather than  the Option<&i32>
Then unwrap_or to set score to zero if scores does not have an entry for the value 

Accessing Hasmap print values in arbitrary  order 
Just like  in vectors we can iterate over the value of a hashmap as seen:
for(key,value) in &Hasmap{
print(“{key}:{value}”);
}

Hash Maps and Ownership
For types that implement the copy trait the value is copied, while for owned value like string the values will be moved and the hashmap become the new owner
When a type implements the Copy trait, it means that values of that type are copied implicitly when they are assigned to another variable or passed to a function.
This is mostly not accurate but will help understand: by default all items stored on the heap don’t implement the copy trait, however those who are on the stack do.
We can do some magic to implement  wrapper to the heap stored items so that they implement the copy trait.
For type that don’t implement the copy trait, pass reference instead.

Updating a Hash Map
There are three ways to do it:
1.Overwriting a Value
If we add two key values pair that contains same name for the key but different values, the former will be ignored and the latter be used  as the correct value.
2.Adding a Key and Value Only If a Key Isn’t Present
Check if key exists , if not add else don’t addthere is a special Api called entry that takes the key you want to check as a parameter, the return value of entry method is an enum called Entry, that represents a value that might or might not exist.
scores.entry(String::from(“Blue”)).or_insert(50);since we already have Blue this won’t be inserted.or_insert method on Entry returns a mutable reference to the value for the corresponding entry key if that key exists and if not, insert the parameter as the corresponding value for this key and return the reference to this new value.
Updating a Value Based on the Old Value
Look up keys value, then update it based on the old value,
The split_whitespace method returns an iterator of string slices that are sub-slices of the original string slice, separated by whitespace.

Hashing Functions
by default hash maps contain a hashing function called SipHash that can provide resistance to denial of service attacks involving hash tablesit is slower but offers better security, you can swap it out in favour of your own choice that is faster by specifying a different hasherHasher is a type that implements the BuildHasher trait.
Error Handlingrust has a panic macro - when a program panics it will print a failure message, unwind , clean up the stack and quit.Via an env variable you can make rust display the call stack when a panic occurs to make it easier to track down the source of the panic.
By default, when program panics rust will unwind which means rust walks back up the stack and cleans data from each function it encounters,however walking back and cleaning up is a lot of work therefore rust gives you the opportunity of aborting instead-this however won’t clean up the stack.Memory that the program was using will then need to be cleaned by the operating system.
If in your project you need to make the resulting binary as small as possible you can switch from unwinding to aborting by addingpanic=‘abort’ to the appropriate profile sections in your cargo.toml file eg

[profile.release]panic= ‘abort’

Using a panic Backtrace

When a rust program panics, the last two lines are the most important, one shows where our program panicked and the next is a note that tells us to run with env variable RUST_BACKTRACE=1 to display a backtrace.A backtrace is a list of all functions that have been called to get to this point.
The key to reading a backtrace is to start from the top until you see the files that you wrote, that’s the spot where the problem originatedthe lines above the spot are code that your code has called, the lines below are code that called your code.this after and before code lines might include rust code, etc lib code, crates code etc.To run a program with backtrace, we call our code as shown i.e 
RUST_BACKTRACE=1 cargo run

This will print a stack trace and we should start investigating our panic at the first line we see that we wrote.the backtrace exact output will depend on the os and rust version you’re using.in order to get backtraces with all this information, debug symbols must be enabled, by default debug symbols are are enabled when we run cargo run /cargo build without the release flag.
Recoverable Errors with Result
Most errors are not serious enough to require a program to panic.i.e you want to access a file but it does not exist, it does not make sense to panic but rather create the missing instead.
The Result enum has two variants , Ok and Error as follows
enum Result<T, E>{Ok(T),
Err(E)
}

The T and E are generic type parameters:T will return the type of value that will be returned in a success case within the Ok variant.E will return the type of Error that will be returned in a failure case within the Error variant.
Because Result has these generic type parameters, we can use the Result type and the functions defined on it in many different situations where the successful value and error value we want to return may differ.Example of a function that return result type because the function could fail:
use std::fs::File;
fn main() {
    let greeting_file_result = File::open("hello.txt");
}
In the case where File::open succeeds, the value of greeting_file_result will be an instance of Ok that contains a file handle, in the case where it fails  the greeting_file_result variable will contain an instance of the Err that has more information about the error.One way to handle the Result type is by using the match expression just like we do for Option<T>

greeting_file = match greeting_file_result {
Ok(file)=>file,Err(error)=>panic!(“Problem opening file{:?}”,error),
}In the match expression arm note we have not used Result::Ok or Result::Err. `this is because just like the Option enum Result is included directly in the prelude.Matching on Different Errors

The code above will panic not matter why File::open failedhowever we want to take different action for different failure reasons.if the file doesn’t not exist we can to create a file and return the handle to the new file, else let the program panic.to do so we can add an inner match expression.refer to could_fail_handle_multiple fn in GitHubShortcuts for Panic on Error:unwrap and expect
Using match works but it can be a bit verbose and not communicate intent well
Result<T,E> has got various helper methods to help it accomplish  a specific task.

1. Unwrap method is a shortcut for the match expression, 
If the Result is the Ok variant, then unwrap will return value inside the Ok.
If the Result is the Err variant , unwrap will call the panic! Macro.
let open_file=File::open(“rust.txt”).unwrap();

2. Expect.expect works same as unwrap but you have the option to specify the message passed once a panic happens unlike unwrap which has got a default error message
Propagating Errors
When a functions implementation calls something that might fail, instead of handling the error within the function itself, you can return the error to the calling code, so that it can decide what to do.- Propagating the errorit give more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code
Below is a function that reads a username from a file, if the file does not exist, the function returns the error to the code that called it:
~ Refer to propagating Errors in GitHub.
The calling code will then handle the Ok or Err variants respectively.
I.e in case of Err: it can panic or do more complicated operation such as  look for file in adjacent locations,, or set a default username.
This procedure in rust is so common that Rust provides the Question mark operator to make this easier.

Shortcut for Propagating Error : The ? Operator
The ? Placed after a result value is defined to work in almost the same way as the match expression we defined to handle Result above:if the result is an Ok, the value inside the Ok will get returned from this expression, else the value inside Err will get returned and propagate to the calling code and terminate the program.
One difference between ? Operator and match is that 
Error values that have the ? Operator called on them , go through the from function defined in the From trait in the std lib.
It is used to convert values from one type into another type.
When the ? Operator calls the from function, the error type received is converted into the error type defined in the return type of the current functionThis is useful when a function returns one type to represent all the ways a function might fail, even if parts might fails for many different reasons.As seen the ? Operator is useful in eliminating boilerplate and makes this function implementation simpler.We can even make our code shorter by chaining  the methods calls immediately after the ? Operator
Refer to GitHub on how to chain operators.Where the ? Operator can be used
The ? Operator can only be used in functions whose return type is compatible with the value of the ? Is used onthis is because the ? Operator is designed to perform an early return of a value out of the function.
Basically we can only use the ? Operator in function whose return type is either Result, Option on any type that implements the FromResidual.
The behaviour of  the ? Operator when Called on Option<T> is the same a Result<T,E>  if None() is returned the function will have early exit , if some() the value inside the some will be the resulting value of the expression
We can use ? Operator on a Result if the  function returns a Result, likewise we can use the ? Operator on an Option if the function returns an Option., but we cannot mix and match, as the ? Operator won’t convert result to Option and vice versea.

In such cases where such conversion is necessary we can use methods like Ok on result or the ok_or method on Option to do the conversion explicitly.
Main fn in Rust is the entry and exit point of an executable program, and hence there are restriction on what it can return.
~As seen from previous example it returns () only , and this is because there are restricions on what it’s return type can be to enable programs behave as expected.Luckily main can also return  a  Result<(), E> 
See below code where we change return type to be Result<(), Box<dyn Error>> and we added a Ok(()) at the enduse std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
 The Box<dyn Error> type is a trait object which for now you can read as “any kind of Error” until we learn about in chapter 17.
When a main function returns a Result<(),E> , The executable will exit with a value of ) if main returns Ok(()) and will exit with nonzero value if main returns an Err value.in C executables return integers when they exit; programs that exit successful return 0  while those that  error, return with any other integer 
Rust also follows this convection.To Panic or not To panic

 We should only panic when our application receives a bad state/or something unexpected happens(accassing an out of bounds memory)	 or when doing test(we won’t know if test failed unless it panics),in cases where we expect an error do to some operation or user input  it is better to return a Result<T,E>

You can call panic for any error situation, however by doing this you are making a decision on behalf of the calling code whether the error is recoverable or not.You could choose to return a Result value to give the calling code options	: hence it calls panic only when the Err valuee is unrecoverable.
In most situations we would return Result to the calling code, but in situations like as examples, prototype-codes and tests it is advised to panic instead.Examples, Prototype Code, Tests  

Including robust error handling in examples can lead to the examples being unclear. for example you might find methods like unwrap that could cause the function to panic being used as placeholder for a more robust error handling technique I.e match.so you might use unwrap and expect when prototyping	and then come up later with better error handling techniques.similar when doing tests youd want when a call to a method fails the whole function to fail even if that particular method is not what you were testing for. Hence calling unwrap and or expect is exactly what you should use.Cases in Which you have More information than the compiler

In some situations, you can have a logic that returns a Result value even though it is not logically possible for the logic to return an error.The compiler will force you to handle the Error even though is not there, because it thinks the logic has the possibility of failing.
In such situations, its perfectly acceptable to call unwrap and even better have expect to document why the error is failing
Consider code below:    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");

127.0.0.1 is  a valid Ip address.
We can see that  we are parsing a hardcoded valid ip address but the will force to handle the Err variant of Result by either asking us to add expect or unwrap because the hardcoded value doesn’t change the type of the parse method.consider a situation where we are accepting the ip address as an input from the user, then our code would make much more sense to have expect  or unwrap since the user input be wrong.Guidelines for Error Handling
It advisable to have you code panic when it’s possible your code could end up in a bad state.A bad state is when some assumption, guarantee or contract has been brokenAlso:1 BadState- is when something that is unexpected happens as opposed to something that will likely happen occasionally, like a user entering data in the wrong format.
If someone calls your code and passes values that don’t make sense it is advisable to return an error so that the user of the library can decide what do in that case.in situations where continuing would be harmful or insecure, the best choice would be to panic and alert the user of you lib about the error so they can make the necessary fix.Similarly if you calling external code and  it returns an invalid state that you have no way to fix, calling panic is the best situation here.
If you attempt to access an invalid data: Out of bounds memory - trying to access memory that doesn’t belong to the current data structure will cause the standard library to call panic, this protects from vulnerabilities. (accessing invalid data is the main cause of vulnerability)
However when failure is expected, it is better to return a Result than to make a panic call.
Example is a parser being given malformed data or a https request returning a status suggesting we have hit a rate limit. In such cases we propagate the error to the code calling it to decide how it will handle it
Functions have contracts: their behaviour is only guaranteed only when the inputs meet a particular requirement.contract violation indicates a caller side bug and its not the kind of error you want the calling code to handle, in fact there is not reasonable way for the calling to recover.
It makes sense to panic when a contract violation occurs.

The rust type system does lots of the checks hence we do not need to manually do the check our selves. How? Well the parameters are typed no? I.e:if you pass other types rather than option<T> the code knows it does not have to handle a value which can be something and nothing rather than the specified type.
Again if you use u32, this ensure what integer is passed is never negative.
Creating Custom  Types for Validation

We might have a program with a function that expects a number but we want it to be btw 1-100 of cos we can write an if statement to check for this condition.
Now assume that the program, has lots of function that need to do the same checks, ofcos we can write the check for every program  but this would be a bit hard on the performance  of our app.

An ideal solution for this would be to implement a custom type and put the validation in a function to create a new instance of the type rather than repeating validations everywhere.(the associated function will have the only if statement)


Generic Types, Traits and lifetimes
Generics is rust’s tool for handling duplication of concepts - (abstract stand-ins for concrete types)
We use generics to create definitions of a function signatures or structs, which we can then use with many different concrete datatypes.	


Why generics?prevents code duplication,
Makes code more flexible
Provides more functionality to callers of our code.

Generics in Functionsfor example assume you have a two functions to check the largest value in an integer list and as well as in a char list, we will combine the two functions to a single function that uses generics, since the type software this values will be different I.e [i32] and [char]Now instead of the function we can use generics and have only one function that accepts a generic datatypeswe must first define the type name declaration in between the function name and  parameter list.refer to code.
In structure Definition
We use generic in structs just as we use them in functions I.e
struct Point<T> {
    x: T,
    y: T,
}
Let tranform= Point {x:5,y:2}
However this means that when creating an instance of the struct, the datatype of the values must be of the same type since the struct definition is generic over some type T. So if x is i32 then y must  be i32 as well.however	incase you want the values of your structure instance to be of different type that is still possible as shown 
struct Point<T, U> {
    x: T,
    y: U,
}

refer to code.
However if you find that your code requires a lot of generic type definition then that is an indicator that you should restructure your code.

In Enum Definitions	Enums can also hold generic datatypes in their variants, i.e 
enum Option<T>{
Some(T),
None
}T is a generic type for the Option<T> enumSome(T) variant holds the value of T while None Variant doesn’t;t hold any value.

Enum can have multiple generics as well I.e Result enum
enum Result<T,E>{	Ok(T),        Err(E)
} 

In Method Definitions

We can  implement methods on structs and enums and use generics for their type definitions.
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}

Note that we have to declare T just after impl so we can use T to specify that we’re implementing methods on the type Point<T>
refer to multiple_generics in GitHub to understand more on generics.
This means that the method will be available to any instance of the structure no matter the type passed.
One thing though, we can have a method that will only work with instance of the struct of a certain type only by specifying the type in the method definition.impl Point<f32> {
    fn x(&self) -> &T {
        &self.x
    }
}Performance of Code Using Generics
Generics don’t relly affect the runtime speeds of your code due to monomorphization of the code.this is the process of turning generic types to concrete types that are used when compiled

Traits: Defining Shared Behavior
A trait defines functionality a particular type has and can share with other types,A way of grouping types together by the methods we call on them- Types behaviour consists of the methods we call on that typeTypes behaviour consists of the methods we can call on that type.
Different types share the same behaviour if we call the same methods on all of those types.trait definitions are a way to group method signatures together to define a set of behaviours necessary to accomplish some purpose.
 Trait example 

pub trait summary{fn summarize(&self)->String;
}

Make the triait public so as to make it accessible so crates depending on this crate can access to as well,
Declare trait with trait keyword followed by its name followed by curly brackets.Inside curly brackets declare the method signatures that describe the behaviours of  the type that implements this trait, we won’t have the function body instead	 a semicolon.Each type that implements this trait, must provide its own custom behaviour for the body of the function.A trait can have multiple methods on its body : the method signatures are listed one per line and each line ends in a semicolon.

Implementing a Trait on a Type
Check GitHub.

Trait -type restrictions:

Note :
We can only implement a trait ton a type only if one of the trait or type is local to our crateWe can implement std lib traits like Display on our own custom types 
We can use our own traits on external typeswe can’t implement external traits on external types.
This is enforced by the Orhan rule, this ensures other people code doesn’t break your own and vice versa
Default Implementations
Sometimes it’s useful to have default behaviour for some or all of the methods in a trait instead of requiring implementations for all methods on every type.we can then override each methods behaviour while implementing it on a particular type.here we define the struct, define a trait and the method inside it(including body) then implement the trait on the struct, the implementation block will be empty I.e:impl Summary for tweet{}
Create an instance of the structure and call the method inside the trait implementing the struct
Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.

Pub trait Summary{
Fn summarize_author(&self)->String;

Fn summarize(&self)->String{format!(“author is {}”, new_article.summarize()}
}

}
Traits as Parameters
We can use traits to define functions that accept many different types.

Notify function  calls the summarise method on its Item parameter  which is of some type that implements the summary trait.
// refer to GitHub for definition of below variable you don’t understand 
i.epub struct AnyStruct {
Something:whatevertype
} 

Implement Summary for AnyStruct{
fn somemethod(&self)->String{
} 
run the code with a type that implements the Summary trait otherwise the code won’t compile.
}
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

Trait Bound Syntax

The impl trait syntax works for straightforward cases but is actually syntax sugar for a longer form known as trait bound; it looks like this:
we place the trait Bound inside the angle brackets after a colon after the generic type parameter.
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
//seems familiar? Generics.we can have two parameters that implement summary as shown pub fn Notify(item1:&impl Summary, item2:&impl Summary){}
Clearly the impl trait is the easiest however incases as below where we want to force the two parameters to have same type,the trait bound might be the best option(using the impl trait is okay as well if you want the parameters to be of different types however they should implement the Summary trait.)
Pub fn Notify<T:Summary>(item1:&T,item2:&T){
}Specifying Multiple Trait Bounds with the + Syntax
Say we wanted notify to use display formatting as well as summarise on Item.we can specify this with  +syntax:
pub fn notify(item: &(impl Summary + Display)) {}
we can also use the +syntax with trait bound as such:pub fn notify<T:Display+Summary>(item:&T){}
	
Traits as parameter of a function

The args parameter requires a value that implements the iterator trait and returns string values
pub fn build(
        mut args: impl Iterator<Item = String>,
    )Clearer Trait Bounds with where Clauses
Using too many traits has a downside,Each generic has its own trait bound , so function with multiple generic parameters can contain lots of trait bounds information between  the functions name and its parameter list making function hard to read.
Rust provides a syntax we can specify trait bounds inside a  where clause after the functions signature. So instead of writing
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {

We can write :
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{

Less clutteredReturning Types that Implement Traits

We can also use the impl trait syntax  in the return position to return a value of some type that implements a trait 
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
 This means that the fn returns a Tweet of some type that implements summary trait without naming the concrete type.

Using Trait Bounds to Conditionally Implement Methods
by using a trait bound with impl block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits.
Example:
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}


Validating References with Lifetimes

Ensures that references are valid for as long as we need them.
Are implicit and referred.z
Layman’s understanding:The variable with the shorter lifetime cannot be assigned to the one with the longer lifetime - refer to the books illustration and code

Generic Lifetimes in Functions

// when using references as parameters rust needs to ensure that the reference returned is valid
// in this case rust does not know whether the returned reference is text1 or text2 and how it relates to the two
// hence we need to use a lifetimes

fn the_longest(text1:&str,text2:&str)->&str{
    if text1.len()>text2.len() {
        return text1
    }else{
        return text2
    }

}

Lifetime Annotation Syntax

Lifetimes annotations don’t change how long the references live rather, they describe the relationship of the lifetimes of multiple references to each other without affecting the lifetimes.

Refernce->apostrophe->space->apostrophe type

& i32 - a reference
&’a i32 - a reference with explicit lifetime 
&’a mut i32 - a mutable reference with explicit lifetime 

One lifetime annotation does not have much meaning by itself because annotations are meant to tell rust how generic lifetimes parameters of multiple  references relate to each other.

Lifetime Annotations in Function Signatures

We want the returned reference to be valid as long as the two parameters  are valid..

We declare generic lifetime parameters in angle brackets just as we did for generic type parameters

fn the_longest<‘a>(text1:&’a str,text2:&’a str)->&’a str{
    if text1.len()>text2.len() {
        return text1
    }else{
        return text2
    }

}
This means that the function takes two parameters  which live at least as long as lifetime ‘a.
In practise it means the lifetime of the returned reference is the same as the smaller of the lifetimes of the str referencesto understand above  check code below:fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}

Result reference something that is valid until the end of the inner scope.

Thinking in Terms of Lifetimes
Lifetimes parameters needs to be related for them to work. 
It all about connecting the reference parameters of a function and the return reference as well


Lifetime Annotations in Struct Definitions
 Structs define owned types but with lifetimes we can define references as well.we would need to add lifetime annotations on every reference in the struct.

struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}	
Lifetime Elision
Lifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes.
By default the compiler can add lifetimes annotation for us hence we don’t really need to specify lifetime annotation in some function signaturehowever note there are 3 rules that the compiler uses to do this and sometimes the rules might not apply hence the compiler will throws errors in order to give us the opportunity to write the lifetime annotations ourselves.
Here they are :
1. Each parameter gets its own lifetime.
  2. If there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters
  3. If there are multiple input lifetime parameters, but one of them is &self or &mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters.

For example you don’t have to annotate a parameter if it’d not related  in anyway to the return referencethere are other rules check them out, it good to know them.(they are mostly used by compiler)

Lifetime Annotations in Method Definitions

When we implement methods on a struct with lifetimes
impl<'a> Annotation<'a> {
    fn level(&self) -> i32 {
        3
    }
}

The Static Lifetime

One special lifetime we need to discuss is 'static, which denotes that the affected reference can live for the entire duration of the program.
let s: &'static str = "I have a static lifetime.";



How to Write Tests

Functions that verify non-test code works as expected.rust test features
1.test attribute,
2 macros,
3.Should_panic attribute.

The Anatomy of a Test Function
1. assert! - test macro to check if some conditionn evaluates to true. 
Eg assert!(6>4)
2. assert_eq! - test macro to check for equality in the results
Eg assert_eq!(result,40) result here is expected to be 40.
Order of the left and right don’t matter
3. assert_ne! - test macro to check for inequality in the results (pass is values are unequal)
Order of the left and right don’t matterwhen the assertion fails this macros print their arguments using the debug formatting which means values compared must implement the PartialEq and Debug traits
All primitive types and most of the std library implements this.For structs and enums that you define yourself you’ll need to implement partialEq to assert  equality of those types.You’ll also need to implement Debug  to print the values when assertion fails.
Quite straightforward though:
#[derive(PartialEq, Debug)]

Adding Custom Failure Messages
Custom messages will help you further understand more when your assertion fails, what the problem might be
Any arguments passed after the required arguments will be passed along with the format macro!
Check GitHub for more.
 assert!(greetings("Louis").contains(name),"Greetings did not contain name,value was `{}`",greetings(name));since name is something else other than Louis this test will fail and the assert will print the extra output


Checking for Panics with should_panic
In addition to checking return values it’s important to check that our code handles error conditions as expected.
The test passes if the code inside the fn panics and the test fails if the code inside the function don’t panic

struct Guess {
    value: i32,
}

impl Guess {
    fn new(some_number: i32) {
        if some_number < 5 {
            panic!("less than one")
        } else {
            println!("not less than one")
        }
    }
}

…
#[test]
#[should_panic]
fn greater_than_100() {
        Guess::new(200);
    }
should_panic should be after the test attribute and before the function.
Should_panic passes when the the panic macro is run and fails if no panic macro is run 
Should panic is sometimes not precise as the text will pass whenever the code panic regardless of the reason- we should try to make it as precise as possible.
Check GitHub for full code

Using Result<T, E> in Tests
You can’t use the should_panic attribute when using Result<T, E>

Controlling How Tests Are Run
Cargo test compiles into a resulting test binary.By default the test are run in  parralel, but we can control the behaviour of this tests using command line optionssome options are passed to cargo test before the binary and other are passed to the binarywe separate the two using a separator I.ecargo test  -- help -shows the options you can pass to cargo test.cargo test -- -- help - shows the options you can pass to the resulting binary

Running Tests in Parallel or Consecutively
By default in parallel using threads
However you must ensure that the test s don’t depend on each other, including shared environment, such as current working directory or environmental variables.
To prevent parallel test we can specify the test to run on a single thread as shownI.e cargo test -- -- test-threads=1

Showing Function Output
 If a test contains a println! And the test passes, we won’t see the println statement however if the test fails the we will see the println output in the terminal
If we wan the println output to be displayed during the passed test we can add

Cargo test -- -- show-output.

Running a Subset of Tests by Name
Running Single Tests

Cargo test name of the test

Filtering to Run Multiple Tests
Say you have a couple test starting with the keyword add I.e (add_two, add_five , etc) you can just say cargo test add and all the test with add at the start will run.
Cargo test addif you want to run all test in a particular module, just specify the name of the module after cargo test
Cargo test main

Ignoring Some Tests Unless Specifically Requested
Some tests might be alittle bit time consuming hence we might not want tot run themwe can add the #[ignore] attribute after the #[test] attribute

To run the ignored test we use :cargo test -- -- ignored


Test Organization

Two categories of test  
1. Unit test- smaller at particular to one module at a time, can test private interfaces
2. Integration tests. External to your library and use your code like any other external code, using only public interface and multiple modules at a time.

Unit Tests
Test each unit of code in isolation to determine where the code is not working as expected.
Put the unit test in each file together with the code they are testing.
 The convention is to create a module named tests in each file to contain the test function and annotate the module with  #[cfg(test)]

The Tests Module and #[cfg(test)]

#[cfg(test)] tells rust to compile and run test only when you specify cargo test not when you specify cargo build.
This reduces compile time as well as space in the resulting articfact,because the test are not included.cfg - means configuration

Testing Private Functions
Private functions are function in a particular module.I.e we create a module named tests for each file containing our rust code that need to be tested.essentially module tests will be a child of our main module.since child modules can access items of their ancestors as shown in the module chapter we learnt  some time ago.hence we don’t need to explicitly annotate our fn with public keyword

Integration Tests
Individual parts of our code can work well  separately but have issues when required to work together with other parts and hence the need of integration tests.

The tests Directory
 To create integration test we first need tests directory, next to srccargo knows where to look for integration tests (tests dir) and we can create as many tests files as we want.each file will be compiled as its own crate.
- Import the library into each test crate.
- We don’t need annotation as cargo will only compile this when cargo test is run.
When we run cargo test, rust runs 
- Unit test 
- Integration test
- Doc tests.
If any of the test fails rust won’t continue with the subsequent tests.to run integration separately you can run:cargo test -- test namefile
Submodules in Integration Tests



An I/O Project: Building a Command Line Program

Writing Error Messages to Standard Error Instead of Standard Output
cargo run > output.txt -> This tells the shell to print the the standard output contents to the output.txt file,however if we run this we might get some of the error messages printed out by println! In the filewe should instead	 print to the standard error for error messages and standard output for successful data
We do this by using eprintln! For standard error and println! For standard output.


Functional Language Features: Iterators and Closures

Closures
Anonymous functions you can save in a variable or pass as arguments to other functions.
user_preference.unwrap_or_else(|| self.most_stocked())- closure with no arguments, no value in between the ||

Capturing the Environment with Closures
Closures unlike normal functions can capture their environment
Check code.

Closure Type Inference and Annotation
 Diff btw closures and functions:
1.closures don’t require you annotate the type of the parameters or the return value.
-because functions are stored in an exposed interface to your users and hence everyone needs to agree on what the particular type of a  value the functions uses and returns. Closures aren’t used in an exposed interface.
2. Closures are typically short and relevant only within a narrow context rather than an arbitrary scenario.-compiler can infer the types in this limited contexts, though some times type annotations may be needed.
3. Closures can capture their environments unlike in functionswe can add type annotations for more clarity as seenlet expensive_closure=|num:u32|->u32{println!(“calculating slowly…”);thread::sleep(Duration::from_secs(2));num} closure body has only one expression so one can remove the curly brackets(in one liners I think)
the compiler can only infer one concrete type for each of the parameters and their return value.for example the code below won’t compile because  it was already annotated as a String:
    let example_closure = |x| x;
    let s = example_closure(String::from("hello"));
    let n = example_closure(5);


Capturing References or Moving Ownership

Closures can capture values from their environment  in three ways, which directly map to the three ways a function can take parameter:1. Borrowing immutably
2. Borrowing mutably
3. Taking ownershipThe closure decides which of these to use based on what the body of the function does with the captured values.
Closures can also bind to a variable and we can call the closure by  adding parenthesis to the variable name just as in function names.

To force closure to take ownership despite its body not needing to we can use the keyword move before the parameter list. I.e:
move || println!("From thread: {list:?}”)
This technique is mostly useful when passing a closure to a new thread to move the data so its owned by the new thread:

use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}

There is guarantee among which of the new thread or main thread will finish executing first and drop it values, hence we cannot pass a reference of data  to the new thread from the main thread as the data might have been dropped when main finishes before new thread.

Moving Captured Values Out of Closures and the Fn Traits
A closure body can do any of the following:1. Move a captured value out of a closure
2.mutate the captured value
3.neither move nor mutate the value.
4.capture nothing from the environment.

Closures automatically implement one or more of these traits:1.FnOnce-applies to closures that can be called once.
All closures implement this trait since they can be calledif a closure moves out the captured value then that means the closure can only implement this trait. 
Closures that move the captured values out of its body will only implement FNOnce and none of the other traits, because it can only be called once.
2.FnMut-Applies to closures that don’t move captured values out of their body but might mutate the captured values.3. Fn-Applies to closures that neither move nor mutate captured values, as well as those that capture nothing from the environment.this closures can be called more than once without mutating their environments.impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}

Functions also implement all three of the Fn traits too.if what we want to do does not require capturing a value from the environment, we can use the name of the function rather than a closure.
I.e we can do this: instead of a closure, to get a new empty vector if the value is None.
unwrap_or_else(Vec::new);

Processing a Series of Items with Iterators

Iterators allow you to perform some task on a sequence of items in turn.
In rust iterators are lazy, meaning the have no effect until you call the method that consumes the iterator,
I.e this function by itself won’t do a thing, it will just create an iterator and store in a variable  let v1 = vec![1, 2, 3];

  let v1_iter = v1.iter();
To use it we would have to do something like this 

for value in v1.iter(){println!(“{}”,value);
}

For example writing a for loop , implicitly creates then consumes the iterator

The Iterator Trait and the next Method
All iterators implement a trait known as Iterator. Here is the implementation:

pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
New syntax: type Item and Self::item are Associated types which we will learn in chapter 19.
Basically the Item type will be the type returned from the next method.
The next method returns one item at a time wrapped in Some and None when iteration is over.
The next method can be called on iterators directly.
Note: Calling the next method on an iterator changes its internal state(to keep track of where it is in the sequence), so the iterator needs to mutable.
In the for loop above we didn’t need to make the iterator mutable since the for loop takes ownership, making the iterator mutable by default.

Values we get from the calls to next are immutable references to the values in the vec.if we want an iterator that takes ownership and returns owned values, we can call the into_iter instead of itersimilar if we want to iterate over mutable references we can call iter_mut

Methods that Consume the Iterator
The Iterator trait has a bunch of methods provided by the default implementation from std lib.Some of these methods call the next method in their definition, which is why you are required to implement the next method when implementing the Iterator trait.Methods that call next are called consuming adapters.an example is sum method, which takes ownership of the iterator and iterates through the items by repeatedly calling next, thus consuming the iterator.Doing so it adds each item into a running total and returns the total when iteration is complete.
 #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
We can’t use v1_iter again since sum takes ownership.

Methods that Produce Other Iterators
Iterator adapters are methods defined on the iterator trait that don’t consume the iterator, instead they produce iterators by changing some aspect of the original Iterator. E.g map method.Map takes a closure to call on each item as the items are iterated through.it returns a new iterator that produces the modified items. I.e add one
Let v1=vec![1,2,3];
let v1_iter=v1.iter().map(|x|x+1);

However this code won’t work because iterator adapters are lazy and we need to consume the iterator.we can do so by using the collect method, it consumes the iterator and collects the resulting value into a vector. As shown
Let added_vec=v1.iter().map(|x|x+1).collect();

Using Closures that Capture Their Environment

Many iterator adapters take closures as arguments, and commonly the closures well specify as arguments to the iterator adapters capture their environment.
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}
fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
into_iter- takes ownership of the vec

Comparing Performance: Loops vs. Iterators

Iterators although a high level abstraction, generally perform slightly better than loops,this is because of the zero-cost abstraction, which means the abstraction imposes no runtime overhead.




Customizing Builds with Release Profiles
Release profiles are customisable and predefined profiles with different configuration that allow programmer to have lots of option when compiling code.

Dev:cargo build
Release: cargo build —release

Each profile has defaults settings but can be changed in the cargo.toml file I.e

[profile.dev]
opt-level=0

[profile.release]
opt-level=3

Publishing a Crate to Crates.io
Crates.io- A crates registry where we can share code by publishing your own package.

Making Useful Documentation Comments
Accurately documenting your code will help other users know how and when to use them. Use //
Rust has another kind of comment for documentation  known conveniently as a documentation comment, that generates HTML documentation.The HTML displays the contents for public API items intended for programmers interested in knowing how to use your crate as opposed to how your crate is implemented.
The use three slashes and support markdown notation for formatting the text.
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}

We can generate the HTML documentation from this document by running cargo doc.this will run the rustic tools and puts the generated HTML documentation in the target/doc directory.

For convenience running cargo doc —open will build the HTMl for your current crate’s documentation as well as documentation for all your crates dependancies and open result in a web browser.

Commonly Used Sections
We used # Examples Markdown heading in listing 14-1 to create a section in html with the title Examples,other commonly used sections:-PanicsThe scenarios in which the function being documented could panic.-Errorsif the function returns a result describing the kinds of errors that might occur and what conditions might cause those errors returned can be helpful.-Safetyif the function is unsafe to call, there should be a section explaining why?

Documentation Comments as Tests
Adding code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonusrunning cargo test will run the code examples as tests

Commenting Contained Items
//!- adds documentation to the item that contains the comments rather than to the items following the comments,used typically inside the crate root file (src/lib.rs) or inside a module to document the crate or module as a whole.
Useful for describing crates and modules especially

Exporting a Convenient Public API with pub use

Say we made a crate named art, inorder for our clients to use that crate items I.e structs and fns, they would need to bring them into scope via use statements as shown i.estruct
use::art::kinds::primaryColorfnuse::art::utils::mixcheck GitHub for more:
they would need to be slightly conversant with the crate hierarchy in order to know what to import and how to import correctly
Also when we run cargo doc on the front page of the crate documentation we don’t get to see the re-exports
However rust has a trick to remove the internal organisation from the public API by using pub use to re-export items to the top-leveli.e :pub use self::kinds::primaryColor
pub::use::self::utils::mixthis time if we run cargo doc our users can see the re-exports from the front-page making it easier to use our code.
Also this will re-export to the top level such that they can import items from the art crate as use art::mix

Incases where there are nested modules , re-exporting the types at the top level can make a significant difference in how users use your crate.gives more flexibility,

Setting Up a Crates.io Account

Adding Metadata to a New Crate
Before packaging a crate you have to add some metadata in the package section of the crates cargo.toml file

[package]
name=“guessing game”. //uniquedescription and license are required so people know what your crate does and under what term they can use it.if you try to run cargo publish without them it will fail
 Here is how a complete crate with metadata should be :[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

Publishing to Crates.io

Once you have an account and Api key and all metadata ready, you can now publish to crates.ioa publish is permanent and cannot be overwritten nor deleted.

Publishing a New Version of an Existing Crate
 Change the version number in cargo.toml file then republish
Use semantic Versioning rules to decide what an appropriate next version would be based on your changes (rust book)

Deprecating Versions from Crates.io with cargo yank
Although you can’t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency
To yank  run:cargo yank --vers 1.0.1. (version number to yank)
To undo yank cargo yank --vers 1.0.1 --undo
Cargo Workspaces
as you build your lib crate you might find that it continues to become bigger and bigger, cargo has a feature that can help you break down the crate into multiple crates and develop in tandem.
Creating a Workspace
Is a set of packages that share the same	 cargo.lock and output directory.we start by creating a workspace directory say add:mkdir add 
in the add workspace dir we create a cargo.toml file to configure the workspace.it won’t have a [package] section instead it will have a [workspace] section.it will allows us to add members to the workspace by specifying the path to the package with our binary crate; in this case the path is adder,
I.e 
[workspace]

members = [
    "adder",
]
So now we create the adder binary crate by running cargo new adder within the add directory.at this point we can build the workspace by running cargo build
The target directory will be generated in the add directory not inside the adder directory, even if we run cargo build inside the adder directory, this is to ensure the crate in the workspace depend on each other and avoid unnecessary rebuilding.Creating the Second Package in the Workspace
Edit your cargo.toml file [workspace]

members = [
    "adder",
    "add_one",
]

Then generate the lib crate:
cargo new add_one --lib

Now to have our binary (adder) depend on the lib crate (add_one), we can add [dependencies]
add_one={path =“../add_one”}
Cargo doesn’t assume that crates in a workspace depend	on each other, we have to be explicit.now to use the add_one fn in add_one crate, import as shown use::add_one::add_one
add_one(5);

To build the whole workspace we do; in the top level;
Cargo build 
to run a specific crate we use:cargo run -p adder

Depending on an External Package in a Workspace

Notice that the project has only one cargo.lock file at the top level, this ensures that all crates use the same version of dependencies,

Lets add the rand crate to the add_one/crgo.toml in the dependencies section 

[dependencies]
rand=“0.8.5”
We can now use rand in the add_one/src/lib.rs and use cargo build to build whole workspace,

However we can’t use it in another crate in the workspace until we add it to the crates cargo.toml file, we will get an error

This will also update the info on the cargo.lock file in the top-level,

Adding a Test to a Workspace
Let’s add a test to the add_one lib crate function.now run cargo run on the top level directory, this will run tests for all crates,we can run tests separately  as well, by specifying the -p and the name of the crate as shown:
Cargo test -p add_onesimilary to publish the packages in a workspace we would need to do so individually,
i.e cargo publish -p add_one

Use workspace as your project grows.

Installing Binaries with cargo install

Cargo install allows you to install and use binary crates locally,you can only installl crates that have a binary target.- a runnable  program that is created if the crate has a src.main.rs file.once you install the package, the second last line shows the location of the crate,
Make sure the location is under the PATH  variable to be able to run the crate,I.e cargo install ripgrep

To use ripgrep:rg —help

Extending Cargo with Custom Commands


Smart Pointers (Introduction)
Pointer is a general concept for a variable that contains an address in memory
Most common kind of pointer in rust is a reference,
Smart pointers are data structures that act like a pointer but have additional metadata and capabilities,
References only borrow data while in many cases smart pointers own the data they point to,examples of smart pointers=>Vec<T>, String ; because they own some memory and allow you to manipulate it.Smart pointers are implemented using Structs,they implement the Derek and Drop traits.Deref allows an instance of a smart pointer to behave like a reference, so you can write your code to work with both,
DropAllows you to customise the code thats’s run when an instance of the smart pointer goes out of scope,
Examples of smart pointers:
Box<T>-for allocating values on the heap,
Rc<T> a reference counting type that enables multiple ownership,
Ref<T> and RefMut<T> accessed through RefCell<T>- a type that enforces the borrowing rules at runtime instead of compile time

Interior Mutability- A pattern where an immutable type exposes an API for mutating and interior value.

Using Box<T> to Point to Data on the Heap

Most straightforward smart pointer is a box
Boxxes allow you to store data on the heap rather than stack., what remains on the stack is a pointer to the heap data,
When to use them?
-when you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size,-when you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so,
-when you want to own a value and you only care its a type that implements a particular trait rather than being of a specific type.

Using a Box<T> to Store Data on the Heap
 Syntax and how to interact with values stored within a Box<T>
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
Box will be stored on the stack but the data it points to will be in the heap,when both goes out of scope it will be deallocated	,

Enabling Recursive Types with Boxes
A value of a recursive type can have another value of the same type as part of itself,
Recursive types pose an issue because at compile time rust needs to know how much space a type takes up, nesting of recursive types could theoretically continue infinitely, so rust might not know how much space the value needs .because boxes have a known size, we can enable recursive types by inserting a box in the recursive type defination.i.e let’s explore the cons list(a data type found commonly in functional programming),

More Information About the Cons List
Is a data structure that comes from LISP programming language and is made up of nested pairs, and is the lisp version of linked list.its name comes from cons function(construct function) in Lisp that constructs a new pair from its two arguments.by calling cons on a pair consisting of a value and another pair, we can construct cons list made up of recursive pairs
Pseudocode representation of a cons list contains the list 1,2,3 each pair in parentheses.
(1, (2, (3, Nil)))

Each item in a cons list contains two elements; the value of the current item and the next item.the last items in the list contains only a value called NIL without a next Item.A cons list is produced ny recursively calling the cons function.
Here is an enum defination of a cons listenum List {
    Cons(i32, List),
    Nil,
}

Using the List store the values 1,2,3 would look like this :use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}

The first cons list hold 1 and another cons list, the list value here is another cons value that holds 2and another list value,this list value is one more Cons value that holds 3 and a list value, which finally holds Nil, the non-recursive variant that signals the end of the list.

However if we try to compile we get an error that this type “has infinite size”,
This is because the list holds another value of itself recursively, so rust can’t figure out how much space it needs to store the list.
Let look at how rust computes the space required for a non-recursive type.

Computing the Size of a Non-Recursive Type
 Remember this enum ?enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
To determine the space the enum needs, rust goes through each of the variant to see which variant needs the most space.Because only one variant will be used, the most space Message will need is the space it would take to store the largest of its variants.


Contrast this to when rust tries to determine the space a recursive type needs.The compiler starts by looking at the Cons variant which holds an i32 and a list,Therefore Cons needs an amount of space equal to size of an i32 plus size of list.to figure out the size of the list the complier looks at its variants, starting with the Cons variant which holds  an I32 value  and a value of type list and this goes on infinitely

Using Box<T> to Get a Recursive Type with a Known Size

Because rust can’t figure out the size to allocate for recursive type, it suggest in the error message we use indirection.
“indirection” means that instead of storing a value directly, we should change the data structure to store the value indirectly by storing a pointer to the value instead.A pointers size doesn’t;t change based on amount of data its pointing too.we can then put the Box<T> inside the cons variant instead of another list value directly.the Box<T> will point to another list value that will be on the heap rather than inside a Cons variant,we will still have lists holding other lists but the implementation  is more like placing the items next to one another.this will look like belowenum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}

By using a box, we’ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a List value
Boxes provide only the indirection and heap allocation; they don’t have any other special capabilities,

Treating Smart Pointers Like Regular References with the Deref Trait

Implementing the Derek trait allows you to customise the behaviour of the dereference operator
By implementing Derek in such a way that a smart pointer can be treated like a regular reference allows us to write code that operates on references and use that code with smart pointers too.

Following the Pointer to the Value
A regular reference is a type of pointer (points to data stored somewhere in memory)

fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
Y being a reference to the x value, if we want to assert that 5 is equal to the value of held be Y, we must use the dereference operator to follow the value it is pointing to.

Using Box<T> Like a Reference
We can rewrite this to use a box instead

let x = 5;
ley y = Box::new(x)

assert_eq!(5, x);
assert_eq!(5, *y);

Y is an instance of Box, which points to a copied value of x rather than a reference of pointing to the x value.

Defining Our Own Smart Pointer
Lets Build our own smart pointer(MyBox) like Box<T> so that we can understand how smart pointers operate differently from references.

Box<T> - is a a tuple struct with one element

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

If we substitute the above Box for MyBox, the code won’t compile, this is because rust doesn’t know how to deference the MyBox struct.we haven’t implemented the ability for it to perform dereferencing, and we do this by implementing Deref trait.

Treating a Type Like a Reference by Implementing the Deref Trait

Use::std::ops::Deref;

impl <T> Deref for MyBox<T>{type Target = T;

Fn deref(&self)->Self::Target{&self.0
}}

type Target = T defines an associated type for the Defer trait to use.
Self.0 = accesses the first value in a tuple struct.
Behind the scenes rust actually run this code*(y.deref())
Without the deference trait, the compiler can only dereference references.
If the deref method is supposed to return a reference to the value, why then do we need a deference operator outside the parenthesis?*(y.deref())
This is because we don’t want to take ownership of the value returned, since this would mean the value would be moved out of self

Implicit Deref Coercions with Functions and Methods
Deref coercion- Converts a reference to a type that implements the Deref trait into a reference to another type.
I.e converts &String to &str because String implements the Deref trait such that it returns &str.
Deref coercion is a convinience rust performs on arguments to functions and methods and works only on types that implement the Deref trait.
It happens automatically when we pass a reference to a particular types values as an argument to a function and it does not match the parameter type in the function definition.
It also lets us write more code that can work for references as well as smart pointers.
Again it prevents us from manually derefencing because we would need to use all this symbols which make our code hard to read and write.

How Deref Coercion Interacts with Mutability

We can use DerefMut trait to override the * glob operator on mutable references.
Rust does deref coercion when it finds types and trait implementations in three cases:
* From &T to &U when T: Deref<Target=U>
* From &mut T to &mut U when T: DerefMut<Target=U>
* From &mut T to &U when T: Deref<Target=U>
* 
Rust will also coerce a mutable reference to an immutable one. But the reverse is not possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile).


Running Code on Cleanup with the Drop Trait
Drop is the trait that lets you customise what happens when a value is about to go out of scope.
Can be used to release resources like files and network issues.
It is almost always used when implementing a smart pointer, I.e when Box<T> is dropped it deallocates all the space on the heap that box points to.
To avoid memory leaks, in some languages, for some types, programmers must call code to free up resources when they finish using an instance of the type,in rust you can specify that a particular code be run whenever a value goes out of scope, hence you don’t need to be careful about placing cleanup code everywhere.
You specify the code to be run when implementing the drop trait.The drop trait requires you to implement a method called drop that takes in a mutable reference to self,
The Drop trait is included in the prelude, so no need to bring into scope,
Variables are dropped in reverse order of their creation, so d is dropped before c (check functionality in code)

Dropping a Value Early with std::mem::drop
It is not straightforward to disable the drop trait as that goes against the reason for its existence	.
However you might need to clean up a value early, in the.e when using smart pointers that manages locks, you might want to force the drop method so that the other code can access the lock, rust doesn’t let you can drop manually, instead you can call std::mem::drop function.
drop method from the drop trait is a destructor, -a function that cleans up an instance, opposite of constructor - a function that creates an instance.you can’t called the drop method from the trait directly, if you want to drop a value before end of its scope,this is because rust would still call the drop at the end of values scope causing a double free error. 
Drop from std::men::drop is in the prelude already so we can do i.e:

fn main(){let c= customStruct{name:String::from(“Louis”);
}
drop(c)
}
If you had a drop impl of the Drop trait, whatever is specified in there will be run once drop is called,
You could use the code in the body of drop to make cleanup safe and convinient. I.e you could use it to create your own memory allocator.

Rc<T>, the Reference Counted Smart Pointer

In majority of the cases, ownership is clear, we know what what value is owned by what variable,
However there are cases where the value might have multiple owners, I.e in graph data structures, multiple edges might point to the same node.
This means that the node is owned by all the edges pointing to it.To enable multiple ownership explicitly we have to use Rust type Rc<T> which means reference counting.
It keeps track of the number of references to a value to determine if it is in use or not.if the reference count is zero then the value is okay to be cleaned 
We use Rc<T> when we want to allocate some data on the heap for our program but we can’t determine at compile time which part will finish using the data last.
Note: RC<T> is only for use in single threaded scenarios, we will discuss how to handle reference counting in multithreaded scenarios,

Using Rc<T> to Share Data
Must be included in prelude,I.e use std::rc:Rc

I.e assume we want to use the Cons List such that we create two lists that both share ownership of a third list. Typically you’d this of doing it this way:
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}

But this won’t work since a has already given ownership to b and can’t give it to c at the same time (Value used here after move)
We could decide to change the definition to use references, and this will take you down the lifetimes rabbit hole to ensure every element in the list lives as long as the entire list.this may not work for some scenarios.
Instead we can change our definition of Box<T> to Rc<T>
Now when we create b, we clone the Rc<List> that a is holding thereby increasing the number of references from one to two and letting a and b share ownership of the data in that Rc<List>
We will also clone a when creating c, this will increase our references from 2 to 3

enum List {Cons(i32,Rc<List>),
Nil
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

Fn main(){let a=Rc::new(Cons(5,Rc::new(10,Rc::new(Nil))));
Let b =Cons(3,Rc::clone(&a));
Let c=Cons(4,Rc::clone(&a));

We can use a.clone() as well but this will make a deep copy of the data which takes time,The implementation of the Rc::clone(&a) increments the rc counter and does not do a deep clone making it the perfect candidate to use in such scenarios.
Cloning an Rc<T> Increases the Reference Count

Let’s see how the references counter changes when a value goes out of scope.
We will include an inner scope around c
Check example in GitHub.whenever a value goes out of scope the Rc will automagically reduce the counter.Rc allows you to share data between different parts of your program for reading only(immutably)If we could share data mutably then this would break the borrowing rules in chapter 4:Multiple mutable borrows to the same place can cause data races and inconsistencies. 

RefCell<T> and the Interior Mutability Pattern

Interior mutability is a design pattern in rust that allows you to mutate data even when there are immutable references to that data- this is normally not allowed due to borrowing rules.to mutate data, the unsafe code pattern us usedunsafe code means we are checking the rules manually instead of relying on the compiler to check the rules.
Unsafe code in then wrapped in a safe API and the outer type is still immutable,

Enforcing Borrowing Rules at Runtime with RefCell<T>
Unlike Rc<T>, the RefCell<T> represents single ownership over the data it holds.
With other types borrowing rules invariants are enforced at runtime while with RefCell<T>, if you break these rules, the program panics and exists.
Compile time error checking has a few advantages I.e:1. Error will be caught sooner,
2.No runtime analysis performance overhead
Runtime error checking has some advantages as well1.Certain memory safe computations are allowed and would have been disallowed in compile time.
Static analysis, like the rust compiler, is inherently conservative - some properties of code are impossible to detect by just analysing the code, I.e the Halting Problem.(research this)

If the rust compiler can’t be sure the code compiles with ownership rules, it might reject a correct program- conservative.
If the compiler accepts incorrect program, that would be catastrophic, but if the compiler rejects correct code the developer will be inconvenienced.RefCell<T> is useful when sure your code follows borrowing rules but the compiler is unable to understand and guarantee that.
Similar to Rc<T> , RefCell<T> is only for use in single threaded scenarios.
* Rc<T> enables multiple owners of the same data; Box<T> and RefCell<T> have single owners.
* Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime.
* Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.
  Mutating a value inside an immutable value in interior mutability pattern

Interior Mutability: A Mutable Borrow to an Immutable Value
Let x=5;
Let y =&mut xAbove code is not valid rust code since we are borrowing  an immutable value mutably.
However there are scenarios where it would be useful for a value to mutate itself in its methods only  but appear immutable to other code.	using RefCell<T> is one way to have interior mutability but it does not get around borrowing rules completely, the borrow checker at compile time allows this interior mutability, the borrowing rules are checked at runtime. Incase of a violation then you get a panic.A Use Case for Interior Mutability: Mock Objects



Reference Cycles Can Leak Memory
Memory leak- creating memory that is never cleaned.memory leaks can happens in rust though at minimal. If we use RC<T> or RefCell<T> it’s possible for the leaks to appear, this is because it’s possible to Crete defences where items refer to each other in a cycle.This can cause the reference counter never to reach 0 during dropping.


Fearless Concurrency
Concurrent programming- is where different parts of the program execute independently 
Parallel programming - is where different parts of the program execute at the same time.

Rust ownership rules play a major role in preventing concurrency/parrallesism errors and help catch this error in compile time rather than runtime.(Fearless concurrency)

Using Threads to Run Code Simultaneously

Threads enable us to break our code and run it some parts of it independently in threads resulting in massive performance gains, but again introduces complexity
There is no guarantee of the order in which parts of your code in different threads will run.
This can result to :1.race conditions- threads accessing resources in an inconsistent order.
2.dealocks - where two threads are waiting for each other preventing each thread from continuing
3. Bugs that happen in certain situations and are hard to reproduce.

Rust std uses 1:1 model for thread implementation, where by a program uses one operating system thread per one language thread.

Creating a New Thread with spawn

We use thread::spawn to spawn a ew thread, and pass a closure to it to run  code on a new thread.
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}

When the main thread completes all other threads are shut down, whether complete or not.

Waiting for All Threads to Finish Using join Handles

There is no guarantee that the spawned thread will get to run and also the spawned thread can be terminated at nay time.
To fix that we use the JoinHandle which is a type from thread::spawn	
joinHandles are owned value, where when we call the join method on, waiting until the thread finishes before exiting

Let multi=thread::spawn(||{
For I in 1..9{println!(“Thread {:?}”,I);
}
})
Multi.join().unwrap();

Calling join on multi blocks the thread currently running until the thread at the multi terminates,Blocking a thread means that thread is prevented from performing work or exiting


Using move Closures with Threads

Move keyword is mostly used when passing ownership of a value to the closure from its environment , especially when using thread::spawn()
When passing a value to a closure in a new thread it is key that you move it inside the closure because rust does not know how long the thread will run and how long the reference will be valid, before some external factor leads to its deallocation, which might leads to bugs, inconsistencies or even panics.


Using Message Passing to Transfer Data Between Threads
One approach to safe concurrency is message passing. This is where threads or actors communicate by sending each other messages containing data,
To facilitate this rust std has an implementation of channels.Channels facilitate the sending of messages from one three to another.it has :
1.Transmitter-
2.Receiver-one part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages.
A channel is said to be dropped if either the transmitter or receiver is dropped.to cretae a channel we use the MPSC from the std lib

MPSC=Mutliple Producer Single Consumera channel can have multiple ends producing values but will only have one receiving end that consumes the values.	

The transmitter has a method send which ids of type Result<T,E> to return an error incase the value being passed is somehow dropped or invalid.

The receiver as well has methods that are of type Result<T,E>the receiver has two methods:1-recv  blocks the thread currently running  until a value is sent down the channel
2.try_recv- this does not block the thread but returns the Result <T,E> immediately, an Ok holding the message value and an error if there aren’t any messages at that time.
Using try_recv is useful if the thread has other work to do while waiting for the messages.

We could write a loop that calls try_recv every so often to check for the message otherwise continue with other work before checking again for the value.


Channels and Ownership Transference

Ownership rules are vital for us to write safe and concurrent rust code.
pub fn spawned_to_main(){
    let (tx ,rx)=mpsc::channel();


    thread::spawn(move|| {
        let val = String::from("hi");
        tx.send(val).unwrap();
        Println!(“the value of val is {val :?}”.   // this won’t compile as send takes ownership, also the receiver will take ownership after the value is sent.
    });

    println!("Received: {}", rx.recv().unwrap());
    }

Sending Multiple Values and Seeing the Receiver Waiting

To show that the threads can communicate in concurrency.

pub fn multi_spawned_to_main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vecs = vec![
            String::from("hi"),
            String::from("thread"),
            String::from("am"),
            String::from("Louis")
        ];

        for vec in vecs {
            tx.send(vec.clone()).unwrap();
            thread::sleep(Duration::from_secs(2));
            if vec == "Louis" {
                print!("Exiting the thread");
                exit(1);
            }
        }
    });

    for received in rx {
        println!("Received: {}", received);
    }
}


Creating Multiple Producers by Cloning the Transmitter

To create multiple transmitters we call clone on the tx

Let (tx, rx ) misc::channel()
Let tx1= tx.clone();

// now we can call this separately on another thread to send messages to the receiver in concurrency.



Shared-State Concurrency
We can pass messages concurrently to other threads using channels but that is not the only way, threads can access shared state data as well.this means that data will have multiple ownership unlike in channels where data is owned by on person(sender or receiver).this adds complexity, just as we saw this concept using smart-pointers(RC<T>), but rusts ownership	system can be beneficial in such scenarios.

Using Mutexes to Allow Access to Data from One Thread at a Time

Mutex- abbreviation for mutual exclusion, allows only one thread to access data at a given time.A thread must first signal that it wants access to the mutex by acquiring a mutex lockthe lock is a data structure in the mutex that keeps track of who has exclusive access to the data.
Mutex has a reputation to be hard to use, this is because of these two rules
1. You must attempt to acquire the lock before using the data.
2. When you are done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.

The API of Mutex<T>

Using Mutex in single-threaded situations
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);  // new Mutex

    {
        let mut num = m.lock().unwrap();    //acuire the lock first
        *num = 6;      // mutate/ use the data from mutex.
    }

    println!("m = {m:?}");  // m is 6
}

Mutex<T> is a smart pointer, the call to lock returns, a smart pointer called MutexGuard, locked in LockResult, that we handled with the call to unwrap.
The smart pointer implements both Deref and Drop, this is seen above since we are able to change the value using * and also the when the inner function goes out of scope, drop is executed.


Sharing a Mutex<T> Between Multiple Threads

use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
This will not compile as we cannot moved ownership of counter into multiple threads.
We could try giving the value multiple owners by using RC<T>, we wrap the mutex inside RC as shown RC::new(Mutex::new(0)), but if we try that (check the book example) the compiler complains about  RC<Mutex<i32>> not being sent to threads safely. And goes further to tell us the reason, because Trait send is not implemented for RC<Mutex<i32>>Unfortunately Rc is not safe to share across threads, and cn lead to unexpected bugs and memory leaks,The issue with RC is it does not have any concurrency primitive to make sure that changes to the counter cannot be interrupted by another thread.


Atomic Reference Counting with Arc<T>
Fortunately, we have ARC<T> which is a type of RC that is safe to use in concurrent situations
Check out std::sync::atomic for more info.they work like primitive type but are safe to share across threads.

Why are primitives not atomic? This is because thread safety come s with a performance penalty that you only need to pay when you really need to.
Your single threaded application will run faster without atomics.


Mutex can help divide our code operation to different  parts, each handled by different threads where each  can then update the final result with its part.	
The std::sync::atomic provides much simpler types for you to handle in different operations, please check that out.


Similarities Between RefCell<T>/Rc<T> and Mutex<T>/Arc<T>


As noticed in the example above counter is immutable but we could get a mutable reference	 to it.This means that Mutex<T> provides interior mutability same as CellRefCell<T> gives interior mutability access to RC<T> while use Mutex<T> to mutate the contents inside Arc<T>

Just like RC<T> which comes with the risk of creating reference cycles mutex also come with the risk of creating deadlock when not used correctly.
This occurs when an operation needs to lock two resources and two threads have acquired one of the locks, causing them to wait for each other forever.if you are interested in deadlocks, try creating a rust program that has a deadlock, then research on deadlock mitigation strategies for muteness in any language, then try implementing in rust. The std lib API doc for Mutex and MutexGuard offers useful information.

Extensible Concurrency with the Sync and Send Traits







Small notes.
- Inorder for a closure to take ownership of the value we should use the move keyword, otherwise it will borrow mutably or immutably depending on how you have used it.
-Indexing operation will always borrow.
-rust will never automatically create deep copies as that results to increased runtime performance. (Making deeps copies on the heap is much slower than making copies on the stack)
